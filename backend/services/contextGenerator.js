const fs = require('fs');
const path = require('path');

const IGNORE = new Set(['node_modules', '.git', '.venv', '__pycache__']);
const IMPORTANT_FILES = ['README.md', 'README', 'package.json', 'requirements.txt', 'pyproject.toml', 'setup.py', 'package-lock.json', 'Pipfile', 'Gemfile', 'composer.json'];

function safeRead(filePath, maxBytes = 200 * 1024) {
  try {
    const buf = fs.readFileSync(filePath, { encoding: 'utf8' });
    return buf.slice(0, maxBytes);
  } catch (err) {
    return null;
  }
}

function readFirstLines(filePath, maxLines = 50) {
  const content = safeRead(filePath);
  if (!content) return `Could not read file`;
  return content.split(/\r?\n/).slice(0, maxLines).join('\n');
}

function buildTree(dir, depth = 3) {
  // shallow tree to avoid huge output
  try {
    const items = fs.readdirSync(dir, { withFileTypes: true });
    items.sort((a, b) => a.name.localeCompare(b.name));
    const lines = [];
    for (const it of items) {
      if (IGNORE.has(it.name)) continue;
      const isDir = it.isDirectory();
      lines.push(`${isDir ? 'ðŸ“' : 'ðŸ“„'} ${it.name}`);
      if (isDir && depth > 1) {
        const sub = buildTree(path.join(dir, it.name), depth - 1).map((l) => '  ' + l);
        lines.push(...sub);
      }
    }
    return lines;
  } catch (err) {
    return [`(error reading directory: ${err.message})`];
  }
}

function detectProject(rootDir) {
  const files = fs.readdirSync(rootDir);
  const lower = files.map((f) => f.toLowerCase());
  const info = { types: [], mainFiles: [], details: {} };
  if (lower.includes('package.json')) {
    info.types.push('node');
    try {
      const pkg = JSON.parse(fs.readFileSync(path.join(rootDir, 'package.json'), 'utf8'));
      info.details.package = { name: pkg.name, scripts: pkg.scripts || {}, dependencies: pkg.dependencies || {}, devDependencies: pkg.devDependencies || {} };
      if (pkg.main) info.mainFiles.push(pkg.main);
    } catch (e) {}
  }
  if (lower.includes('requirements.txt') || lower.includes('pyproject.toml') || lower.includes('setup.py')) {
    info.types.push('python');
  }
  if (lower.some((n) => n.endsWith('.xcodeproj')) || lower.includes('podfile') || lower.includes('package.swift')) {
    info.types.push('ios');
  }
  if (lower.includes('composer.json') || lower.includes('gemfile')) {
    info.types.push('php/ruby');
  }
  // top-level entry files
  ['index.js', 'app.js', 'server.js', 'main.py', 'manage.py', 'index.html'].forEach((f) => {
    if (files.includes(f)) info.mainFiles.push(f);
  });
  return info;
}

function summarizePackage(pkg) {
  try {
    const p = JSON.parse(pkg);
    const deps = Object.keys(p.dependencies || {}).slice(0, 10);
    const dev = Object.keys(p.devDependencies || {}).slice(0, 10);
    return { name: p.name || '', description: p.description || '', scripts: p.scripts || {}, dependencies: deps, devDependencies: dev };
  } catch (e) {
    return null;
  }
}

function listImportantFiles(rootDir) {
  const found = [];
  function walk(dir, rel = '') {
    try {
      const items = fs.readdirSync(dir, { withFileTypes: true });
      for (const it of items) {
        if (IGNORE.has(it.name)) continue;
        const p = path.join(dir, it.name);
        const r = rel ? path.join(rel, it.name) : it.name;
        if (it.isDirectory()) walk(p, r);
        else if (IMPORTANT_FILES.includes(it.name) || /readme/i.test(it.name) || /package.json|setup.py|pyproject.toml|requirements.txt/i.test(it.name) || /index\.(js|ts|py|jsx|tsx)$/.test(it.name)) {
          found.push(r);
        }
      }
    } catch (e) {}
  }
  walk(rootDir);
  return Array.from(new Set(found));
}

async function generateContext(rootDir) {
  const header = `# Project context generated by ContextHub\n\n`;

  // Project detection
  const detected = detectProject(rootDir);
  const types = detected.types.length ? detected.types.join(', ') : 'unknown';

  const stats = { files: 0, size: 0 };
  function statWalk(dir) {
    try {
      const items = fs.readdirSync(dir, { withFileTypes: true });
      for (const it of items) {
        if (IGNORE.has(it.name)) continue;
        const p = path.join(dir, it.name);
        if (it.isDirectory()) statWalk(p);
        else {
          stats.files += 1;
          try { stats.size += fs.statSync(p).size; } catch (e) {}
        }
      }
    } catch (e) {}
  }
  statWalk(rootDir);

  const projectSummary = [];
  projectSummary.push(`**Detected project types:** ${types}`);
  if (detected.details.package) {
    projectSummary.push(`**Package name:** ${detected.details.package.name || '-'} `);
    const deps = Object.keys(detected.details.package.dependencies || {});
    if (deps.length) projectSummary.push(`**Top dependencies:** ${deps.slice(0,8).join(', ')}`);
    const scripts = Object.keys(detected.details.package.scripts || {});
    if (scripts.length) projectSummary.push(`**Scripts:** ${scripts.join(', ')}`);
  }
  projectSummary.push(`**Files (approx):** ${stats.files}`);
  projectSummary.push(`**Estimated size:** ${Math.round(stats.size / 1024)} KB`);

  // directory tree (shallow)
  const treeLines = buildTree(rootDir, 6);

  // Walk entire tree to collect files
  const files = [];
  function walkAll(dir, rel = '') {
    try {
      const items = fs.readdirSync(dir, { withFileTypes: true });
      for (const it of items) {
        if (IGNORE.has(it.name)) continue;
        const p = path.join(dir, it.name);
        const r = rel ? path.join(rel, it.name) : it.name;
        if (it.isDirectory()) walkAll(p, r);
        else {
          let size = 0;
          try { size = fs.statSync(p).size; } catch (e) {}
          files.push({ path: r.replace(/\\/g, '/'), full: p, size });
        }
      }
    } catch (e) {}
  }
  walkAll(rootDir);

  // Limits to avoid huge payloads
  const PER_FILE_PREVIEW_LIMIT = 120 * 1024; // 120 KB per file
  const TOTAL_PREVIEW_LIMIT = 1024 * 1024; // 1 MB total
  let totalPreviewBytes = 0;

  function isTextFile(ext) {
    const txt = new Set(['.js', '.ts', '.jsx', '.tsx', '.py', '.java', '.c', '.cpp', '.h', '.html', '.css', '.json', '.md', '.txt', '.rb', '.go', '.rs', '.php', '.sh', '.yml', '.yaml']);
    return txt.has(ext.toLowerCase());
  }

  function extractHeaderAndSymbols(content, ext) {
    const headerCandidates = [];
    const lines = content.split(/\r?\n/).slice(0, 200);
    // try to find a leading comment block
    if (/\.py$/.test(ext) || ext === '.py') {
      for (const l of lines) { if (/^\s*#/.test(l)) headerCandidates.push(l.replace(/^\s*#\s?/, '')); else break; }
    } else {
      // languages with // or /* */
      for (const l of lines) {
        if (/^\s*\/\//.test(l)) headerCandidates.push(l.replace(/^\s*\/\/\s?/, ''));
        else if (/^\s*\/\*/.test(l)) { headerCandidates.push(l.replace(/^\s*\/\*\s?/, '')); break; }
        else break;
      }
    }
    const header = headerCandidates.join(' ').trim();

    // find symbols
    const symbols = [];
    const joined = lines.join('\n');
    const jsFunc = joined.match(/function\s+([A-Za-z0-9_]+)/g) || [];
    const jsClass = joined.match(/class\s+([A-Za-z0-9_]+)/g) || [];
    const pyDef = joined.match(/def\s+([A-Za-z0-9_]+)/g) || [];
    const pyClass = joined.match(/class\s+([A-Za-z0-9_]+)/g) || [];
    [...jsFunc, ...jsClass, ...pyDef, ...pyClass].forEach((m) => {
      const name = m.split(/\s+/).pop().replace('(', '').replace(/\W/g, '');
      if (name && !symbols.includes(name)) symbols.push(name);
    });

    return { header: header || null, symbols };
  }

  const perFileSummaries = [];
  for (const f of files) {
    const ext = path.extname(f.path).toLowerCase();
    let preview = null;
    let text = null;
    let isText = isTextFile(ext);
    if (isText) {
      const remaining = TOTAL_PREVIEW_LIMIT - totalPreviewBytes;
      if (remaining > 0) {
        const want = Math.min(PER_FILE_PREVIEW_LIMIT, remaining);
        const c = safeRead(f.full, want);
        if (c) {
          preview = c;
          totalPreviewBytes += Buffer.byteLength(preview, 'utf8');
          text = preview;
        }
      }
    }
    let header = null;
    let symbols = [];
    if (text) {
      const r = extractHeaderAndSymbols(text, ext);
      header = r.header;
      symbols = r.symbols;
    }
    perFileSummaries.push({ path: f.path, size: f.size, ext, header, symbols, preview });
  }

  const fence = '```';

  // Suggested prompts for AI
  const prompts = [
    'Summarize the project and list the main modules and where to start reading the code.',
    'Provide setup and run instructions for a developer on macOS and Windows.',
    'List potential issues to watch for when modifying the codebase.',
    'Give a file-by-file summary of the repository, focusing on entry points and configuration files.'
  ];

  let out = header;
  out += `## Project Summary\n\n`;
  out += projectSummary.map((l) => `- ${l}`).join('\n') + '\n\n';

  out += `## How to use this context\n\n`;
  out += `Paste the following sections into your AI assistant to give a full project overview:\n\n- Project Summary\n- File index with previews\n- Directory structure\n\n`;

  out += `## Suggested AI Prompts\n\n` + prompts.map((p) => `- ${p}`).join('\n') + '\n\n';

  out += `## Directory structure (shallow)\n\n` + treeLines.join('\n') + '\n\n';

  out += `## File index and summaries (per-file)\n\n`;
  if (perFileSummaries.length === 0) out += '_No files found._\n\n';
  else {
    for (const f of perFileSummaries) {
      out += `### ${f.path} â€” ${Math.round(f.size / 1024)} KB\n\n`;
      const meta = [];
      meta.push(`- extension: ${f.ext || '(none)'}`);
      if (f.header) meta.push(`- header: ${f.header}`);
      if (f.symbols && f.symbols.length) meta.push(`- symbols: ${f.symbols.slice(0,8).join(', ')}`);
      out += meta.join('\n') + '\n\n';
      if (f.preview) {
        out += `${fence}\n${f.preview}\n${fence}\n\n`;
      } else {
        out += '_No preview available (binary or trimmed)._\n\n';
      }
    }
  }

  out += `---\nGenerated by ContextHub on ${new Date().toISOString()}`;

  return { markdown: out, prompts };
}

module.exports = { generateContext };
