const fs = require('fs');
const path = require('path');

const IGNORE = new Set(['node_modules', '.git', '.venv', '__pycache__']);
const IMPORTANT_FILES = ['README.md', 'README', 'package.json', 'requirements.txt', 'pyproject.toml', 'setup.py', 'package-lock.json', 'Pipfile', 'Gemfile', 'composer.json'];

function safeRead(filePath, maxBytes = 200 * 1024) {
  try {
    const buf = fs.readFileSync(filePath, { encoding: 'utf8' });
    return buf.slice(0, maxBytes);
  } catch (err) {
    return null;
  }
}

function readFirstLines(filePath, maxLines = 50) {
  const content = safeRead(filePath);
  if (!content) return `Could not read file`;
  return content.split(/\r?\n/).slice(0, maxLines).join('\n');
}

function buildTree(dir, depth = 3) {
  // shallow tree to avoid huge output
  try {
    const items = fs.readdirSync(dir, { withFileTypes: true });
    items.sort((a, b) => a.name.localeCompare(b.name));
    const lines = [];
    for (const it of items) {
      if (IGNORE.has(it.name)) continue;
      const isDir = it.isDirectory();
      lines.push(`${isDir ? 'ðŸ“' : 'ðŸ“„'} ${it.name}`);
      if (isDir && depth > 1) {
        const sub = buildTree(path.join(dir, it.name), depth - 1).map((l) => '  ' + l);
        lines.push(...sub);
      }
    }
    return lines;
  } catch (err) {
    return [`(error reading directory: ${err.message})`];
  }
}

function detectProject(rootDir) {
  const files = fs.readdirSync(rootDir);
  const lower = files.map((f) => f.toLowerCase());
  const info = { types: [], mainFiles: [], details: {} };
  if (lower.includes('package.json')) {
    info.types.push('node');
    try {
      const pkg = JSON.parse(fs.readFileSync(path.join(rootDir, 'package.json'), 'utf8'));
      info.details.package = { name: pkg.name, scripts: pkg.scripts || {}, dependencies: pkg.dependencies || {}, devDependencies: pkg.devDependencies || {} };
      if (pkg.main) info.mainFiles.push(pkg.main);
    } catch (e) {}
  }
  if (lower.includes('requirements.txt') || lower.includes('pyproject.toml') || lower.includes('setup.py')) {
    info.types.push('python');
  }
  if (lower.some((n) => n.endsWith('.xcodeproj')) || lower.includes('podfile') || lower.includes('package.swift')) {
    info.types.push('ios');
  }
  if (lower.includes('composer.json') || lower.includes('gemfile')) {
    info.types.push('php/ruby');
  }
  // top-level entry files
  ['index.js', 'app.js', 'server.js', 'main.py', 'manage.py', 'index.html'].forEach((f) => {
    if (files.includes(f)) info.mainFiles.push(f);
  });
  return info;
}

function summarizePackage(pkg) {
  try {
    const p = JSON.parse(pkg);
    const deps = Object.keys(p.dependencies || {}).slice(0, 10);
    const dev = Object.keys(p.devDependencies || {}).slice(0, 10);
    return { name: p.name || '', description: p.description || '', scripts: p.scripts || {}, dependencies: deps, devDependencies: dev };
  } catch (e) {
    return null;
  }
}

function listImportantFiles(rootDir) {
  const found = [];
  function walk(dir, rel = '') {
    try {
      const items = fs.readdirSync(dir, { withFileTypes: true });
      for (const it of items) {
        if (IGNORE.has(it.name)) continue;
        const p = path.join(dir, it.name);
        const r = rel ? path.join(rel, it.name) : it.name;
        if (it.isDirectory()) walk(p, r);
        else if (IMPORTANT_FILES.includes(it.name) || /readme/i.test(it.name) || /package.json|setup.py|pyproject.toml|requirements.txt/i.test(it.name) || /index\.(js|ts|py|jsx|tsx)$/.test(it.name)) {
          found.push(r);
        }
      }
    } catch (e) {}
  }
  walk(rootDir);
  return Array.from(new Set(found));
}

async function generateContext(rootDir) {
  const header = `# Project context generated by ContextHub\n\n`;

  // Project detection
  const detected = detectProject(rootDir);
  const types = detected.types.length ? detected.types.join(', ') : 'unknown';

  const stats = { files: 0, size: 0 };
  function statWalk(dir) {
    try {
      const items = fs.readdirSync(dir, { withFileTypes: true });
      for (const it of items) {
        if (IGNORE.has(it.name)) continue;
        const p = path.join(dir, it.name);
        if (it.isDirectory()) statWalk(p);
        else {
          stats.files += 1;
          try { stats.size += fs.statSync(p).size; } catch (e) {}
        }
      }
    } catch (e) {}
  }
  statWalk(rootDir);

  const projectSummary = [];
  projectSummary.push(`**Detected project types:** ${types}`);
  if (detected.details.package) {
    projectSummary.push(`**Package name:** ${detected.details.package.name || '-'} `);
    const deps = Object.keys(detected.details.package.dependencies || {});
    if (deps.length) projectSummary.push(`**Top dependencies:** ${deps.slice(0,8).join(', ')}`);
    const scripts = Object.keys(detected.details.package.scripts || {});
    if (scripts.length) projectSummary.push(`**Scripts:** ${scripts.join(', ')}`);
  }
  projectSummary.push(`**Files (approx):** ${stats.files}`);
  projectSummary.push(`**Estimated size:** ${Math.round(stats.size / 1024)} KB`);

  // directory tree (shallow)
  const treeLines = buildTree(rootDir, 3);

  // important files and previews
  const important = listImportantFiles(rootDir);
  const previews = [];
  for (const rel of important) {
    const p = path.join(rootDir, rel);
    const content = readFirstLines(p, 200);
    previews.push({ path: rel.replace(/\\/g, '/'), content });
  }

  const fence = '```';

  // Suggested prompts for AI
  const prompts = [
    'Summarize the project and list the main modules and where to start reading the code.',
    'Provide setup and run instructions for a developer on macOS and Windows.',
    'List potential issues to watch for when modifying the codebase.',
  ];

  let out = header;
  out += `## Project Summary\n\n`;
  out += projectSummary.map((l) => `- ${l}`).join('\n') + '\n\n';

  out += `## How to use this context\n\n`;
  out += `Paste the following sections into your AI assistant to give a full project overview:\n\n- Project Summary\n- Important files with previews\n- Directory structure\n\n`;

  out += `## Suggested AI Prompts\n\n` + prompts.map((p) => `- ${p}`).join('\n') + '\n\n';

  out += `## Directory structure (shallow)\n\n` + treeLines.join('\n') + '\n\n';

  out += `## Important files and previews\n\n`;
  if (previews.length === 0) out += '_No important files found._\n\n';
  else {
    for (const f of previews) {
      const safe = (f.content || '').slice(0, 120 * 1024);
      out += `### ${f.path}\n\n${f.path.endsWith('.md') ? safe : fence + '\n' + safe + '\n' + fence}` + '\n\n';
    }
  }

  out += `---\nGenerated by ContextHub on ${new Date().toISOString()}`;

  return { markdown: out, prompts };
}

module.exports = { generateContext };
